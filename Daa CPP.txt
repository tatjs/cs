//1st assignment part 1


//Fibonacci using recursive method

#include<iostream>
using namespace std;

int fib(int num)
{
    if(num<=1)
    {
        return num;
    }
    return fib(num-1)+fib(num-2);
}

int main()
{
    int num;
    cin>>num;

    cout<<fib(num);
    
    return 0 ;
}

-------------------------------------------------
//1st Assignment Part 2

//Fibonacci using non-recursive method

#include<iostream>
using namespace std;

int main()
{
    int num;
    cin>>num;

    int a,b,c;
    a=1;
    b=1;
    cout<<a<<" "<<b;

    for(int i=2;i<num;i++)
    {
        c=a+b;
        cout<<" "<<c<<" ";
        a=b;
        b=c;
    }
    return 0;
}


------------------------------------------------------------
//2nd Assignment

#include <bits/stdc++.h>
#define MAX_TREE_HT 256
using namespace std;

map<char, string> codes;
map<char, int> freq;

struct MinHeapNode
{
	char data;			 
	int freq;			 
	MinHeapNode *left, *right; 
	MinHeapNode(char data, int freq)
	{
		left = right = NULL;
		this->data = data;
		this->freq = freq;
	}
};

struct compare
{
	bool operator()(MinHeapNode* l, MinHeapNode* r)
	{
		return (l->freq > r->freq);
	}
};

void printCodes(struct MinHeapNode* root, string str)
{
	if (!root)
		return;
	if (root->data != '$')
		cout << root->data << ": " << str << "\n";
	printCodes(root->left, str + "0");
	printCodes(root->right, str + "1");
}

void storeCodes(struct MinHeapNode* root, string str)
{
	if (root==NULL)
		return;
	if (root->data != '$')
		codes[root->data]=str;
	storeCodes(root->left, str + "0");
	storeCodes(root->right, str + "1");
}

priority_queue<MinHeapNode*, vector<MinHeapNode*>, compare> minHeap;

void HuffmanCodes(int size)
{
	struct MinHeapNode *left, *right, *top;
	for (map<char, int>::iterator v=freq.begin(); v!=freq.end(); v++)
		minHeap.push(new MinHeapNode(v->first, v->second));
	while (minHeap.size() != 1)
	{
		left = minHeap.top();
		minHeap.pop();
		right = minHeap.top();
		minHeap.pop();
		top = new MinHeapNode('$', left->freq + right->freq);
		top->left = left;
		top->right = right;
		minHeap.push(top);
	}
	storeCodes(minHeap.top(), "");
}

void calcFreq(string str, int n)
{
	for (int i=0; i<str.size(); i++)
		freq[str[i]]++;
}

string decode_file(struct MinHeapNode* root, string s)
{
	string ans = "";
	struct MinHeapNode* curr = root;
	for (int i=0;i<s.size();i++)
	{
		if (s[i] == '0')
		curr = curr->left;
		else
		curr = curr->right;
		if (curr->left==NULL and curr->right==NULL)
		{
			ans += curr->data;
			curr = root;
		}
	}
	return ans+'\0';
}

int main()
{
	string str = "dhananjaypanchghate";
	string encodedString, decodedString;
	calcFreq(str, str.length());
	HuffmanCodes(str.length());
	cout << "Character With there Frequencies:\n";
	for (auto v=codes.begin(); v!=codes.end(); v++)
		cout << v->first <<' ' << v->second << endl;
	for (auto i: str)
		encodedString+=codes[i];
	cout << "\nEncoded Huffman data:\n" << encodedString << endl;
	decodedString = decode_file(minHeap.top(), encodedString);
	cout << "\nDecoded Huffman Data:\n" << decodedString << endl;
	return 0;
}
------------------------------------------------------------
//3rd Assignment - fraction knapsack

#include <bits/stdc++.h>
using namespace std;

struct Item {
    int value, weight;
    Item(int value, int weight)
    {
        this->value = value;
        this->weight = weight;
    }
};

bool cmp(struct Item a, struct Item b)
{
    double r1 = (double)a.value / (double)a.weight;
    double r2 = (double)b.value / (double)b.weight;
    return r1 > r2;
}

double fractionalKnapsack(int W, struct Item arr[], int N)
{
    sort(arr, arr + N, cmp);
    double finalvalue = 0.0;
 
    for (int i = 0; i < N; i++) 
    {
         
        if (arr[i].weight <= W) {
            W -= arr[i].weight;
            finalvalue += arr[i].value;
        }
        else {
            finalvalue
                += arr[i].value
                   * ((double)W / (double)arr[i].weight);
            break;
        }
    }
    return finalvalue;
}

int main()
{
    int W = 50;
    Item arr[] = { { 60, 10 }, { 100, 20 }, { 120, 30 } };
 
    int N = sizeof(arr) / sizeof(arr[0]);
    cout << fractionalKnapsack(W, arr, N);

    return 0;
}
-----------------------------------------------------
//4th Asiignment-0-1 knapsack

#include<iostream>
using namespace std;
int max(int x,int y)
{
    return(x>y)?x:y;
}
int knapsack(int W,int w[],int v[],int n)
{
    int i,wt;
    int K[n+1][W+1];
    for(i=0;i<=n;i++)
    {
        for(wt=0;wt<=W;wt++)
    {
        if(i==0||wt==0)
        K[i][wt]=0;
        else if (w[i-1]<=wt)
        K[i][wt]=max(v[i-1]+K[i-1][wt-w[i-1]],K[i-1][wt]);
        else
        K[i][wt]=K[i-1][wt];
    }
    }
    return K[n][W];
}

int main()
{
    cout<<"Enter the number of items in a Knapsack : ";
    int n,W;
    cin>>n;
    int v[n],w[n];
    for(int i=0;i<n;i++)
    {
        cout<<"Enter value and weight for item "<<i<<":";
        cin>>v[i];
        cin>>w[i];
    }
    cout<<"Enter the capacity of knapsack ";
    cin>>W;
    cout<<knapsack(W,w,v,n);
    return 0;
}
--------------------------------------------------
//5th Assignment-nQueen backtracking

#include<iostream>
using namespace std;
int isSafe(int** arr, int x,int y, int n)
{
    for(int row = 0 ; row<=x;row++)
    {
        if(arr[row][y]==1)
        {
            return false;
        }
    }
    int row = x;
    int col = y;

    while(row>=0 && col>=0)
    {
        if(arr[row][col]==1)
        {
            return false;
        }
        row--;
        col--;
    }
    while(row>=0 && col<n )
    {
        if(arr[row][col]==1)
        {
            return false;
        }
        row--;
        col++;
    }
    return true;
}

bool nQueen(int** arr,int x,int n)
{
    if(x>=n)
    {
        return true;
    }

    for(int col = 0 ;col<n;col++)
    {
        if(isSafe(arr,x,col,n))
        {
            arr[x][col]=1;
            
            if(nQueen(arr,x+1,n)){
                return true;
            }
            arr[x][col]=0;
        }
    }
        return false;
}

int main()
{
    int n;
    cin>>n;

    int** arr = new int*[n];
    for(int i = 0;i<n;i++)
    {
        arr[i]=new int[n];
        for(int j=0;j<n;j++)
        {
            arr[i][j]=0;
        }
    }

    if(nQueen(arr,0,n))
    {
        for(int i = 0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                cout<<arr[i][j]<<" ";
            }
            cout<<endl;
        }
    }
    return 0;
}

